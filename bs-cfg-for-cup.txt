package com.company;
import java_cup.runtime.*;


/* Preliminaries to set up and use the scanner.  */
scan with {: return scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal BOOLEAN, IF, WHILE, DO, FOREACH, FUNCTION, END, BEGIN, PROGRAM, FOR, TYPE, AS, DECIMAL, STRING, DECLARE, IN, RETURN, ELSE, LIST, SWITCH, NULL_LITERAL, CASE, DEFAULT;
terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, DOT;
terminal EQ, PLUSPLUS, MINUSMINUS, PLUS, MINUS, DIV, MULT, MOD, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ, AND, OR, NOT, EQUALS, GREATERTHAN, GREATERTHANEQUALS, LESSTHAN, LESSTHANEQUALS;
terminal EOF, EOL, DOWNTO, TO, THEN, VOID, OF, TERRAIN, GROUP, PLATOON, FORCE, COORD, SOLDIER;
terminal Boolean BOOLEAN_LITERAL;
terminal Integer INTEGER_LITERAL; // decimal??
terminal Double DECIMAL_LITERAL;
terminal String STRING_LITERAL, IDENTIFIER;

/* Non-terminals */


/* Precedences */
precedence nonassoc OR;
precedence nonassoc AND;
precedence nonassoc EQUALS;
precedence left LESSTHAN, GREATERTHAN, GREATERTHANEQUALS, LESSTHANEQUALS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence right NOT, PLUSPLUS, MINUSMINUS, UMINUS;
precedence left POSTPLUSPLUS, POSTMINUSMINUS;

/* The grammar */
Start         ::= FunctionDcls:fds1 Program:p FunctionDcls:fds2 EOF
              ;
FunctionDcls  ::= FunctionDcls:fds FunctionDcl:fd EOL
              |
              ;
FunctionDcl   ::= FUNCTION TypeId:ti IDENTIFIER:id LPAREN Params:p RPAREN EOL Stmts:ss END FUNCTION
              ;
Param         ::= IDENTIFIER:id AS TypeId:ti Params:p
              |
              ;
Params        ::= COMMA Param
              |
              ;
Program       ::= BEGIN PROGRAM EOL Stmts:ss END PROGRAM EOL
              ;
Stmts         ::= Stmts:ss Stmt:s EOL
              |
              ;
Stmt          ::= Dcl:d
              |   Assignment:a
              |   IfStmt:ifs
              |   LoopStmt:ls
              |   SwitchStmt:sws
              |   RETURN ReturnV:rv
              |   FunctionCall:fc
              ;
ReturnV       ::= Variable:v
              |
              ;
IfStmt        ::= IF Expression:e THEN EOL Stmts:ss ElseStmt:els
              ;
ElseStmt      ::= END IF
              |   ELSE ElifStmt:elifs
              ;
ElifStmt      ::= IfStmt:ifs
              |   EOL Stmts:ss END IF
              ;
SwitchStmt    ::= SWITCH Variable:v EOL SwitchCases:swcs SwitchDef:swd END SWITCH
              ;
SwitchCases   ::= SwitchCases:swcs SwitchCase:swc EOL
              |
              ;
SwitchCase    ::= CASE Variable:v EOL Stmts
              ;
SwitchDef     ::= DEFAULT EOL Stmts
              |
              ;
Expression    ::= Expression:e1 PLUS Expression:e2
              |   Expression:e1 MINUS Expression:e2
              |   Expression:e1 MULT Expression:e2
              |   Expression:e1 DIV Expression:e2
              |   Expression:e1 MOD Expression:e2
              |   Expression:e1 EQUALS Expression:e2
              |   Expression:e1 LESSTHAN Expression:e2
              |   Expression:e1 GREATERTHAN Expression:e2
              |   Expression:e1 LESSTHENEQUALS Expression:e2
              |   Expression:e1 GREATERTHANEQUALS Expression:e2
              |   LPAREN Expression:e RPAREN
              |   NOT Expression:e
              |   MINUS Expression:e %prec UMINUS // giver denne præcedens som var det unær minus
              |   PLUSPLUS Expression:e
              |   MINUSMINUS Expression:e
              |   Expression:e PLUSPLUS %prec POSTPLUSPLUS
              |   Expression:e MINUSMINUS %prec POSTMINUSMINUS
              |   Variable:v
              ;
Assignment    ::= NestedId:ni AssignOp:ao RightAssign:ra EOL
              ;
AssignOp      ::= EQ
              |   PLUSEQ
              |   MINUSEQ
              |   MODEQ
              |   MULTEQ
              |   DIVEQ
              ;
RightAssign   ::= Expression:e
              |   Variable:v
              |   FunctionCall:fc
              ;
FunctionCall  ::= NestedId:ni LPAREN Arguments:arg RPAREN
              ;
Arguments     ::= Arg1:arg
              |
              ;
Arg1          ::= Variable:v Arg2:arg
              ;
Arg2          ::= COMMA Arg1:arg
              |
              ;
LoopStmt      ::= WhileStmt:whs
              |   ForStmt:fors
              |   ForeachStmt:fores
              ;
WhileStmt     ::= WHILE Expression:e DO EOL Stmts:ss END WHILE
              ;
ForeachStmt   ::= FOREACH TypeId:ti IDENTIFIER:id IN NestedId:ni DO EOL Stmts END FOREACH
              ;
ForStmt       ::= FOR IntIndex:int1 ForIterator:fi IntIndex:int2 DO EOL Stmts END FOR
              ;
ForIterator   ::= TO
              |   DOWNTO
              ;
Variable      ::= NestedId:ni
              |   StdTypes:st
              ;
StdTypes      ::= DECIMAL_LITERAL:dec
              |   STRING_LITERAL:str
              |   BOOLEAN_LITERAL:bool
              |   INTEGER_LITERAL:int // ny?
              ;
Dcl           ::= DECLARE IDENTIFIER:id Dcls:ds AS TypeId:ti EOL
              ;
Dcls          ::= Dcls:ds COMMA IDENTIFIER:id
              |
              ;
TypeId        ::= IDENTIFIER:id ArrayDcl:ad
              |   DECIMAL ArrayDcl:ad
              |   STRING ArrayDcl:ad
              |   BOOLEAN ArrayDcl:ad
              |   TERRAIN ArrayDcl:ad
              |   GROUP ArrayDcl:ad
              |   PLATOON ArrayDcl:ad
              |   FORCE ArrayDcl:ad
              |   COORD ArrayDcl:ad
              |   SOLDIER ArrayDcl:ad
              |   VOID
              |   LIST OF TypeId:ti
              ;
ArrayDcl      ::= LBRACE IntIndex:index RBRACE
              |
              ;
NestedId      ::= IDENTIFIER:id ChildId:ci
              ;
ChildId       ::= DotNi:dni
              |   LBRACE IntIndex:index RBRACE DotNi:dni
              ;
DotNi         ::= DOT NestedId:ni
              |
              ;
IntIndex      ::= NestedId:ni
              |   INTEGER_LITERAL
              ;
