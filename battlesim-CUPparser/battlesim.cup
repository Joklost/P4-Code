package com.company;
import java_cup.runtime.*;

parser code {:
    Scanner s;
    Parser(Scanner s) {
        this.s = s;
    }
:};

/* Preliminaries to set up and use the scanner.  */
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal BOOLEAN, IF, WHILE, DO, FOREACH, FUNCTION, END,
terminal BEGIN, PROGRAM, FOR, TYPE, AS, DECIMAL, STRING;
terminal DECLARE, IN, RETURN, ELSE, LIST, DECLARATIONS;
terminal SWITCH, NULL_LITERAL, CASE, DEFAULT;

terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, DOT;

terminal EQ, PLUSPLUS, MINUSMINUS, PLUS, MINUS, DIV;
terminal MULT, MOD, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ;
terminal MODEQ, AND, OR, NOT, EQUALS, GREATERTHAN;
terminal GREATERTHANEQUALS, LESSTHAN, LESSTHANEQUALS;

terminal EOF, EOL, DOWNTO, TO, THEN, VOID, OF;
terminal TERRAIN, GROUP, PLATOON, FORCE, COORD, SOLDIER;
terminal SIMULATION, STEP, INTERRUPTS, VECTOR, BARRIER;

terminal Boolean BOOLEAN_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Double DECIMAL_LITERAL;
terminal String STRING_LITERAL, IDENTIFIER;

/* Non-terminals */

nonterminal Start           Start
nonterminal DclBlock        DclBlock
nonterminal FunctionDclList FunctionDcls
nonterminal FunctionDcl     FunctionDcl
nonterminal Param           Param
nonterminal ParamList       Params
nonterminal ParamList       ParamList
nonterminal Program         Program
nonterminal StmtList        Stmts
nonterminal Stmt            Stmt
nonterminal SimStepList     SimSteps
nonterminal SimStep         SimStep
nonterminal Interrupts      Interrupts
nonterminal IfStmt          IfStmt
nonterminal ElseStmt        ElseStmt
nonterminal SwitchCaseList  SwitchCases
nonterminal SwitchCase      SwitchCase
nonterminal SwitchDef       SwitchDef
nonterminal Expression      Expression
nonterminal AssignOp        AssignOp
nonterminal FunctionCall    FunctionCall
nonterminal ArgumentList    Arguments
nonterminal ArgumentList    ArgumentList
nonterminal ArgumentList    Arguments
nonterminal ForIterator     ForIterator
nonterminal Variable        Variable
nonterminal StdLiteral      StdLiteral
nonterminal DclIdList       Dcls
nonterminal TypeIdentifier  TypeId
nonterminal NestedIdentifier NestedId

/* Precedences */
precedence nonassoc OR;
precedence nonassoc AND;
precedence nonassoc EQUALS;
precedence left LESSTHAN, GREATERTHAN, GREATERTHANEQUALS, LESSTHANEQUALS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence right NOT, UMINUS;
precedence left PLUSPLUS, MINUSMINUS;

/* The grammar */
Start         ::= DclBlock:db FunctionDcls:fds1 Program:p FunctionDcls:fds2 EOF                 {: RESULT = new Start(db, fds1, p, fds2, dbleft); :}
              ;
DclBlock      ::= BEGIN DECLARATIONS EOL Stmts:ss END DECLARATIONS EOL                          {: RESULT = new DclBlock(ss, ssleft); :}
              ;
FunctionDcls  ::= FunctionDcls:fds FunctionDcl:fd EOL                                           {: RESULT = fds; fds.addElement(fd); :}
              |                                                                                 {: RESULT = new FunctionDclList(0); :}
              ;
FunctionDcl   ::= FUNCTION TypeId:ti IDENTIFIER:id Params:p EOL Stmts:ss END FUNCTION           {: RESULT = new FunctionDcl(ti, id, p, ss, tileft); :}
              ;
Param         ::= IDENTIFIER:id AS TypeId:ti                                                    {: RESULT = new Param(id, ti, idleft); :}
              ;
Params        ::= LPAREN:l RPAREN                                                               {: RESULT = new ParamList(lleft) :}
              |   LPAREN ParamList:pl RPAREN                                                    {: RESULT = pl; :}
              ;
ParamList     ::= Param:p COMMA ParamList:pl                                                    {: RESULT = pl; pl.addElement(p); :}
              |   Param:p                                                                       {: RESULT = new ParamList(pleft); RESULT.addElement(p); :}
              ;
Program       ::= BEGIN PROGRAM EOL Stmts:ss END PROGRAM EOL                                    {: RESULT = new Program(ss, ssleft); :}
              ;
Stmts         ::= Stmts:ss Stmt:s EOL                                                           {: RESULT = ss; ss.addElement(s); :}
              |                                                                                 {: RESULT = new StmtList(0); :}
              ;
Stmt          ::= DECLARE IDENTIFIER:id Dcls:ds AS TypeId:ti EOL                                {: RESULT = new Dcl(id, ds, ti, idleft); :}
              |   NestedId:ni AssignOp:ao Expression:e EOL                                      {: RESULT = new Assignment(ni, ao, e, nileft); :}
              |   IfStmt:is                                                                     {: RESULT = is; :}
              |   WHILE Expression:e DO EOL Stmts:ss END WHILE                                  {: RESULT = new WhileStmt(e, ss, eleft); :}
              |   FOREACH TypeId:ti IDENTIFIER:id IN NestedId:ni DO EOL Stmts:ss END FOREACH    {: RESULT = new ForeachStmt(ti, id, ni, ss, tileft); :}
              |   FOR NestedId:ni ForIterator:fi Expression:e DO EOL Stmts:ss END FOR           {: RESULT = new ForStmt(ni, fi, e, ss, nileft); :}
              |   SWITCH Variable:v EOL SwitchCases:swcs SwitchDef:swd END SWITCH               {: RESULT = new SwitchStmt(v, swcs, swd, vleft); :}
              |   RETURN Expression:e                                                           {: RESULT = new ReturnExpr(e, eleft); :}
              |   RETURN:r                                                                      {: RESULT = new Return(rleft); :}
              |   FunctionCall:fc                                                               {: RESULT = new FunctionCallStmt(fc, nileft); :}
//              |   SIMULATION NestedId:ni EOL SimSteps:sis Interrupts:is END SIMULATION          {: RESULT = new SimulationStmt(ni, sis, is, nileft); :}
              ;
//SimSteps      ::= SimSteps:sl SimStep:s                                                         {: RESULT = sl; sl.addElement(s); :}
//              |                                                                                 {: RESULT = new SimStepList(0); :}
//              ;
//SimStep       ::= STEP INTEGER_LITERAL:i EOL Stmts:ss                                           {: RESULT = new SimStep(i.intValue, ss, ileft); :}
//              ;
//Interrupts    ::= INTERRUPTS EOL Stmts:ss                                                       {: RESULT = new Interrupts(ss, ssleft); :}
//              ;
IfStmt        ::= IF Expression:e THEN EOL Stmts:ss ElseStmt:els                                {: RESULT = new IfStmt(e, ss, els, eleft); :}
              ;
ElseStmt      ::= END IF:eif                                                                    {: RESULT = new EndIfStmt(eifleft); :}
              |   ELSE IfStmt:ifs                                                               {: RESULT = new ElseIfStmt(ifs, ifsleft); :}
              |   ELSE EOL Stmts:ss END IF                                                      {: RESULT = new ElseEndStmt(ss, ssleft); :}
              ;
SwitchCases   ::= SwitchCases:swcs SwitchCase:swc                                               {: RESULT = swcs; swcs.addElement(swc); :}
              |                                                                                 {: RESULT = new SwitchCaseList(0); :}
              ;
SwitchCase    ::= CASE Variable:v EOL Stmts:ss                                                  {: RESULT = new SwitchCase(v, ss, vleft); :}
              ;
SwitchDef     ::= DEFAULT:d EOL Stmts:ss                                                        {: RESULT = new SwitchDef(ss, dleft); :}
              ;
Expression    ::= Expression:e1 PLUS Expression:e2                                              {: RESULT = new PlusExpr(e1, e2, e1left); :}
              |   Expression:e1 MINUS Expression:e2                                             {: RESULT = new MinusExpr(e1, e2, e1left); :}
              |   Expression:e1 MULT Expression:e2                                              {: RESULT = new MultExpr(e1, e2, e1left); :}
              |   Expression:e1 DIV Expression:e2                                               {: RESULT = new DivExpr(e1, e2, e1left); :}
              |   Expression:e1 MOD Expression:e2                                               {: RESULT = new ModExpr(e1, e2, e1left); :}
              |   Expression:e1 EQUALS Expression:e2                                            {: RESULT = new LogicEqualsExpr(e1, e2, e1left); :}
              |   Expression:e1 LESSTHAN Expression:e2                                          {: RESULT = new LessThanExpr(e1, e2, e1left); :}
              |   Expression:e1 GREATERTHAN Expression:e2                                       {: RESULT = new GreaterThanExpr(e1, e2, e1left); :}
              |   Expression:e1 LESSTHANEQUALS Expression:e2                                    {: RESULT = new LessThanEqualsExpr(e1, e2, e1left); :}
              |   Expression:e1 GREATERTHANEQUALS Expression:e2                                 {: RESULT = new GreaterThanEqualsExpr(e1, e2, e1left); :}
              |   LPAREN Expression:e RPAREN                                                    {: RESULT = e; :}
              |   NOT:not Expression:e                                                          {: RESULT = new NotExpr(e, notleft); :}
              |   MINUS:min Expression:e %prec UMINUS                                           {: RESULT = new UnMinusExpr(e, minleft); :}
              |   Expression:e PLUSPLUS                                                         {: RESULT = new PlusPlusExpr(e, eleft); :}
              |   Expression:e MINUSMINUS                                                       {: RESULT = new MinusMinusExpr(e, eleft); :}
              |   Variable:v                                                                    {: RESULT = new VariableExpr(v, vleft); :}
              |   FunctionCall:fc                                                               {: RESULT = new FunctionCallExpr(fc, nileft); :}
              ;
AssignOp      ::= EQ:eq                                                                         {: RESULT = new EqualsOp(eqleft); :}
              |   PLUSEQ:eq                                                                     {: RESULT = new PlusEqualsOp(eqleft); :}
              |   MINUSEQ:eq                                                                    {: RESULT = new MinusEqualsOp(eqleft); :}
              |   MODEQ:eq                                                                      {: RESULT = new ModEqualsOp(eqleft); :}
              |   MULTEQ:eq                                                                     {: RESULT = new MultEqualsOp(eqleft); :}
              |   DIVEQ:eq                                                                      {: RESULT = new DivEqualsOp(eqleft); :}
              ;
FunctionCall  ::= NestedId:ni Arguments:arg                                                     {: RESULT = new FunctionCall(ni, arg, nileft); :}
              ;
Arguments     ::= LPAREN:l RPAREN                                                               {: RESULT = new ArgumentList(lleft); :}
              |   LPAREN ArgumentList:al RPAREN                                                 {: RESULT = al; :}
              ;
ArgumentList  ::= Expression:e                                                                  {: RESULT = new ArgumentList(eleft); RESULT.addElement(e); :}
              |   Expression:e COMMA ArgumentList:al                                            {: RESULT = al; al.addElement(e); :}
              ;
ForIterator   ::= TO:t                                                                          {: RESULT = new ToIterator(tleft); :}
              |   DOWNTO:t                                                                      {: RESULT = new DownToIterator(tleft); :}
              ;
Variable      ::= NestedId:ni                                                                   {: RESULT = new VariableNestedId(ni, nileft); :}
              |   StdLiteral:st                                                                 {: RESULT = new VariableStdLiteral(st, stleft); :}
              ;
StdLiteral    ::= DECIMAL_LITERAL:dec                                                           {: RESULT = new DecimalLiteral(dec, decleft); :}
              |   STRING_LITERAL:str                                                            {: RESULT = new StringLiteral(str, strleft); :}
              |   BOOLEAN_LITERAL:bool                                                          {: RESULT = new BooleanLiteral(bool, boolleft); :}
              |   INTEGER_LITERAL:int                                                           {: RESULT = new IntegerLiteral(int, intleft); :}
              ;
Dcls          ::= Dcls:ds COMMA IDENTIFIER:id                                                   {: RESULT = ds; ds.addElement(id); :}
              |                                                                                 {: RESULT = new DclIdList(0); :}
              ;
TypeId        ::= DECIMAL:d                                                                     {: RESULT = new TypeDecimal(dleft); :}
              |   STRING:s                                                                      {: RESULT = new TypeString(sleft); :}
              |   BOOLEAN:b                                                                     {: RESULT = new TypeBoolean(bleft); :}
              |   TERRAIN:t                                                                     {: RESULT = new TypeTerrain(tleft); :}
              |   GROUP:g                                                                       {: RESULT = new TypeGroup(gleft); :}
              |   PLATOON:p                                                                     {: RESULT = new TypePlatoon(pleft); :}
              |   FORCE:f                                                                       {: RESULT = new TypeForce(fleft); :}
              |   COORD:c                                                                       {: RESULT = new TypeCoord(cleft); :}
              |   SOLDIER:s                                                                     {: RESULT = new TypeSoldier(sleft); :}
              |   BARRIER:b                                                                     {: RESULT = new TypeBarrier(bleft); :}
              |   VECTOR:v                                                                      {: RESULT = new TypeVector(vleft); :}
              |   VOID:vo                                                                       {: RESULT = new TypeVoid(voleft); :}
              |   LIST OF TypeId:ti                                                             {: RESULT = new TypeList(ti, tileft); :}
              |   TypeId:ty LBRACE Expression:e RBRACE                                          {: RESULT = new TypeArray(ty, e, tyleft); :}
              ;
NestedId      ::= IDENTIFIER:id DOT NestedId:ni                                                 {: RESULT = new NestedIdentifierMember(id, ni, idleft); :}
              |   IDENTIFIER:id LBRACE Expression:e RBRACE DOT NestedId:ni                      {: RESULT = new NestedIdentifierArray(id, e, ni, idleft); :}
              |   IDENTIFIER:id                                                                 {: RESULT = new Identifier(id, idleft); :}
              ;
