package com.company;
import java_cup.runtime.*;

parser code {:
    Scanner s;
    Parser(Scanner s) {
        this.s = s;
    }
:};

/* Preliminaries to set up and use the scanner.  */
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal BOOLEAN, IF, WHILE, DO, FOREACH, FUNCTION, END,
terminal BEGIN, PROGRAM, FOR, TYPE, AS, DECIMAL, STRING;
terminal DECLARE, IN, RETURN, ELSE, LIST, DECLARATIONS;
terminal SWITCH, NULL_LITERAL, CASE, DEFAULT;

terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, DOT;

terminal EQ, PLUSPLUS, MINUSMINUS, PLUS, MINUS, DIV;
terminal MULT, MOD, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ;
terminal MODEQ, AND, OR, NOT, EQUALS, GREATERTHAN;
terminal GREATERTHANEQUALS, LESSTHAN, LESSTHANEQUALS;

terminal EOF, EOL, DOWNTO, TO, THEN, VOID, OF;
terminal TERRAIN, GROUP, PLATOON, FORCE, COORD, SOLDIER;
terminal SIMULATION, STEP, INTERRUPTS, VECTOR, BARRIER;

terminal Boolean BOOLEAN_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Double DECIMAL_LITERAL;
terminal String STRING_LITERAL, IDENTIFIER;

/* Non-terminals */

nonterminal Start           Start
nonterminal DclBlock        DclBlock
nonterminal FunctionDclList FunctionDcls
nonterminal FunctionDcl     FunctionDcl
nonterminal Param           Param
nonterminal ParamList       Params
nonterminal ParamList       ParamList
nonterminal Program         Program
nonterminal StmtList        Stmts
nonterminal Stmt            Stmt
nonterminal SimStepList     SimSteps
nonterminal SimStep         SimStep
nonterminal Interrupts      Interrupts
nonterminal IfStmt          IfStmt
nonterminal ElseStmt        ElseStmt
nonterminal SwitchCaseList  SwitchCases
nonterminal SwitchCase      SwitchCase
nonterminal SwitchDef       SwitchDef
nonterminal Expression      Expression
nonterminal AssignOp        AssignOp
nonterminal FunctionCall    FunctionCall
nonterminal ForIterator     ForIterator
nonterminal Variable        Variable
nonterminal StdLiteral      StdLiteral
nonterminal DclIdList       Dcls
nonterminal TypeIdentifier  TypeId
nonterminal NestedId        NestedId

/* Precedences */
precedence nonassoc OR;
precedence nonassoc AND;
precedence nonassoc EQUALS;
precedence left LESSTHAN, GREATERTHAN, GREATERTHANEQUALS, LESSTHANEQUALS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence right NOT, PLUSPLUS, MINUSMINUS, UMINUS;
precedence left POSTPLUSPLUS, POSTMINUSMINUS;

/* The grammar */
Start         ::= DclBlock:db FunctionDcls:fds1 Program:p FunctionDcls:fds2 EOF                 {: RESULT = new Start(db, fds1, p, fds2, dbleft); :}
              ;
DclBlock      ::= BEGIN DECLARATIONS EOL Stmts:ss END DECLARATIONS EOL                          {: RESULT = new DclBlock(ss, ssleft); :}
              ;
FunctionDcls  ::= FunctionDcls:fds FunctionDcl:fd EOL                                           {: RESULT = fds; fds.addElement(fd); :}
              |                                                                                 {: RESULT = new FunctionDclList(0); :}
              ;
FunctionDcl   ::= FUNCTION TypeId:ti IDENTIFIER:id Params:p EOL Stmts:ss END FUNCTION           {: RESULT = new FunctionDcl(ti, id, p, ss, tileft); :}
              ;
Param         ::= IDENTIFIER:id AS TypeId:ti                                                    {: RESULT = new Param(id, ti, idleft); :}
              ;
Params        ::= LPAREN:l RPAREN                                                               {: RESULT = new ParamList(lleft) :}
              |   LPAREN ParamList:pl RPAREN                                                    {: RESULT = pl; :}
              ;
ParamList     ::= Param:p COMMA ParamList:pl                                                    {: RESULT = pl; pl.addElement(p); :}
              |   Param:p                                                                       {: RESULT = new ParamList(pleft); RESULT.addElement(p); :}
              ;
Program       ::= BEGIN PROGRAM EOL Stmts:ss END PROGRAM EOL                                    {: RESULT = new Program(ss, ssleft); :}
              ;
Stmts         ::= Stmts:ss Stmt:s EOL                                                           {: RESULT = ss; ss.addElement(s); :}
              |                                                                                 {: RESULT = new StmtList(0); :}
              ;
Stmt          ::= DECLARE IDENTIFIER:id Dcls:ds AS TypeId:ti EOL                                {: RESULT = new Dcl(id, ds, ti, idleft); :}
              |   NestedId:ni AssignOp:ao Expression:e EOL                                      {: RESULT = new Assignment(ni, ao, e, nileft); :}
              |   IfStmt:is                                                                     {: RESULT = is; :}
              |   WHILE Expression:e DO EOL Stmts:ss END WHILE                                  {: RESULT = new WhileStmt(e, ss, eleft); :}
              |   FOREACH TypeId:ti IDENTIFIER:id IN NestedId:ni DO EOL Stmts:ss END FOREACH    {: RESULT = new ForeachStmt(ti, id, ni, ss, tileft); :}
              |   FOR NestedId:ni ForIterator:fi Expression:e DO EOL Stmts:ss END FOR           {: RESULT = new ForStmt(ni, fi, e, ss, nileft); :}
              |   SWITCH Variable:v EOL SwitchCases:swcs SwitchDef:swd END SWITCH               {: RESULT = new SwitchStmt(v, swcs, swd, vleft); :}
              |   RETURN Expression:e                                                           {: RESULT = new ReturnExpr(e, eleft); :}
              |   RETURN:r                                                                      {: RESULT = new Return(rleft); :}
              |   FunctionCall:fc                                                               {: RESULT = fc; :}
//              |   SIMULATION NestedId:ni EOL SimSteps:sis Interrupts:is END SIMULATION          {: RESULT = new SimulationStmt(ni, sis, is, nileft); :}
              ;
//SimSteps      ::= SimSteps:sl SimStep:s                                                         {: RESULT = sl; sl.addElement(s); :}
//              |                                                                                 {: RESULT = new SimStepList(0); :}
//              ;
//SimStep       ::= STEP INTEGER_LITERAL:i EOL Stmts:ss                                           {: RESULT = new SimStep(i.intValue, ss, ileft); :}
//              ;
//Interrupts    ::= INTERRUPTS EOL Stmts:ss                                                       {: RESULT = new Interrupts(ss, ssleft); :}
//              ;
IfStmt        ::= IF Expression:e THEN EOL Stmts:ss ElseStmt:els                                {: RESULT = new IfStmt(e, ss, els, eleft); :}
              ;
ElseStmt      ::= END IF:eif                                                                    {: RESULT = new EndIfStmt(eifleft); :}
              |   ELSE IfStmt:ifs                                                               {: RESULT = new ElseIfStmt(ifs, ifsleft); :}
              |   ELSE EOL Stmts:ss END IF                                                      {: RESULT = new ElseStmt(ss, ssleft); :}
              ;
SwitchCases   ::= SwitchCases:swcs SwitchCase:swc                                               {: RESULT = swcs; swcs.addElement(swc); :}
              |                                                                                 {: RESULT = new SwitchCaseList(0); :}
              ;
SwitchCase    ::= CASE Variable:v EOL Stmts:ss                                                  {: RESULT = new SwitchCase(v, ss, vleft); :}
              ;
SwitchDef     ::= DEFAULT EOL Stmts:ss                                                          {: RESULT = new SwitchDef(ss, ssleft); :}
              ;
Expression    ::= Expression:e1 PLUS Expression:e2                                              {: RESULT = new Plus(e1, e2, e1left); :}
              |   Expression:e1 MINUS Expression:e2                                             {: RESULT = new Minus(e1, e2, e1left); :}
              |   Expression:e1 MULT Expression:e2                                              {: RESULT = new Mult(e1, e2, e1left); :}
              |   Expression:e1 DIV Expression:e2                                               {: RESULT = new Div(e1, e2, e1left); :}
              |   Expression:e1 MOD Expression:e2                                               {: RESULT = new Mod(e1, e2, e1left); :}
              |   Expression:e1 EQUALS Expression:e2                                            {: RESULT = new LogicEquals(e1, e2, e1left); :}
              |   Expression:e1 LESSTHAN Expression:e2                                          {: RESULT = new LessThan(e1, e2, e1left); :}
              |   Expression:e1 GREATERTHAN Expression:e2                                       {: RESULT = new GreaterThan(e1, e2, e1left); :}
              |   Expression:e1 LESSTHANEQUALS Expression:e2                                    {: RESULT = new LessThanEquals(e1, e2, e1left); :}
              |   Expression:e1 GREATERTHANEQUALS Expression:e2                                 {: RESULT = new GreaterThanEquals(e1, e2, e1left); :}
              |   LPAREN Expression:e RPAREN                                                    {: RESULT = e; :}
              |   NOT:not Expression:e                                                          {: RESULT = new Not(e, notleft); :}
              |   MINUS:min Expression:e %prec UMINUS                                           {: RESULT = new UnMinus(e, minleft); :}
              |   PLUSPLUS:pp Expression:e                                                      {: RESULT = new PrefixPlusPlus(e, ppleft); :}
              |   MINUSMINUS:mm Expression:e                                                    {: RESULT = new PrefixMinusMinus(e, mmleft); :}
              |   Expression:e PLUSPLUS %prec POSTPLUSPLUS                                      {: RESULT = new PostfixPlusPlus(e, eleft); :}
              |   Expression:e MINUSMINUS %prec POSTMINUSMINUS                                  {: RESULT = new PostfixMinusMinus(e, eleft); :}
              |   Variable:v                                                                    {: RESULT = v; :}
              |   FunctionCall:fc                                                               {: RESULT = fc; :}
              ;
AssignOp      ::= EQ:eq                                                                         {: RESULT = new Equals(eqleft); :}
              |   PLUSEQ:eq                                                                     {: RESULT = new PlusEquals(eqleft); :}
              |   MINUSEQ:eq                                                                    {: RESULT = new MinusEquals(eqleft); :}
              |   MODEQ:eq                                                                      {: RESULT = new ModEquals(eqleft); :}
              |   MULTEQ:eq                                                                     {: RESULT = new MultEquals(eqleft); :}
              |   DIVEQ:eq                                                                      {: RESULT = new DivEquals(eqleft); :}
              ;
FunctionCall  ::= NestedId:ni Arguments:arg                                                     {: RESULT = new FunctionCall(ni, arg, nileft); :}
              ;
Arguments     ::= LPAREN:l RPAREN                                                               {: RESULT = new ArgumentList(lleft); :}
              |   LPAREN ArgumentList:al RPAREN                                                 {: RESULT = al; :}
              ;
ArgumentList  ::= Expression:e                                                                  {: RESULT = new ArgumentList(eleft); RESULT.addElement(e); :}
              |   Expression:e COMMA ArgumentList:al                                            {: RESULT = al; al.addElement(e); :}
              ;
ForIterator   ::= TO:t                                                                          {: RESULT = new To(tleft); :}
              |   DOWNTO:t                                                                      {: RESULT = new DownTo(tleft); :}
              ;
Variable      ::= NestedId:ni                                                                   {: RESULT = ni; :}
              |   StdLiteral:st                                                                 {: RESULT = st; :}
              ;
StdLiteral    ::= DECIMAL_LITERAL:dec                                                           {: RESULT = new Double(dec.doubleValue(), decleft); :}
              |   STRING_LITERAL:str                                                            {: RESULT = new String(str.stringValue(), strleft); :}
              |   BOOLEAN_LITERAL:bool                                                          {: RESULT = new Boolean(bool.booleanValue(), boolleft); :}
              |   INTEGER_LITERAL:int                                                           {: RESULT = new Integer(int.intValue(), intleft); :}
              ;
Dcls          ::= Dcls:ds COMMA IDENTIFIER:id                                                   {: RESULT = ds; ds.addElement(id); :}
              |                                                                                 {: RESULT = new DclIdList(0); :}
              ;
TypeId        ::= DECIMAL:d                                                                     {: RESULT = new DecimalType(dleft); :}
              |   STRING:s                                                                      {: RESULT = new StringType(sleft); :}
              |   BOOLEAN:b                                                                     {: RESULT = new BooleanType(bleft); :}
              |   TERRAIN:t                                                                     {: RESULT = new TerrainType(tleft); :}
              |   GROUP:g                                                                       {: RESULT = new GroupType(gleft); :}
              |   PLATOON:p                                                                     {: RESULT = new PlatoonType(pleft); :}
              |   FORCE:f                                                                       {: RESULT = new ForceType(fleft); :}
              |   COORD:c                                                                       {: RESULT = new CoordType(cleft); :}
              |   SOLDIER:s                                                                     {: RESULT = new SoldierType(sleft); :}
              |   BARRIER:b                                                                     {: RESULT = new BarrierType(bleft); :}
              |   VECTOR:v                                                                      {: RESULT = new VectorType(vleft); :}
              |   VOID:vo                                                                       {: RESULT = new VoidType(voleft); :}
              |   LIST OF TypeId:ti                                                             {: RESULT = new ListType(ti, tileft); :}
              |   TypeId:ty LBRACE StdLiterals:std RBRACE                                       {: RESULT = new ArrayType(ty, std, tyleft); :}
              ;
NestedId      ::= IDENTIFIER:id DOT NestedId:ni                                                 {: RESULT = new NestedChildIdentifier(id, ni, idleft); :}
              |   IDENTIFIER:id LBRACE Expression:e RBRACE DOT NestedId:ni                      {: RESULT = new NestedArrayIdentifier(id, e, ni, idleft); :}
              |   IDENTIFIER:id                                                                 {: RESULT = new Identifier(id, idleft); :}
              ;
