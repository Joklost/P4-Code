package com.company;
import java_cup.runtime.*;


/* Preliminaries to set up and use the scanner.  */
scan with {: return scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal BOOLEAN, IF, WHILE, DO, FOREACH, FUNCTION, END,
terminal BEGIN, PROGRAM, FOR, TYPE, AS, DECIMAL, STRING;
terminal DECLARE, IN, RETURN, ELSE, LIST, DECLARATIONS;
terminal SWITCH, NULL_LITERAL, CASE, DEFAULT;

terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, DOT;

terminal EQ, PLUSPLUS, MINUSMINUS, PLUS, MINUS, DIV;
terminal MULT, MOD, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ;
terminal MODEQ, AND, OR, NOT, EQUALS, GREATERTHAN;
terminal GREATERTHANEQUALS, LESSTHAN, LESSTHANEQUALS;

terminal EOF, EOL, DOWNTO, TO, THEN, VOID, OF;
terminal TERRAIN, GROUP, PLATOON, FORCE, COORD, SOLDIER;
terminal SIMULATION, STEP, INTERRUPTS;

terminal Boolean BOOLEAN_LITERAL;
terminal Integer INTEGER_LITERAL; // decimal??
terminal Double DECIMAL_LITERAL;
terminal String STRING_LITERAL, IDENTIFIER;

/* Non-terminals */
nonterminal Start           Start
nonterminal DclBlock        DclBlock
nonterminal FunctionDclList FunctionDcls
nonterminal FunctionDcl     FunctionDcl
nonterminal Param           Param
nonterminal ParamList       Params
nonterminal ParamList       ParamList
nonterminal Program         Program
nonterminal StmtList        Stmts
nonterminal Stmt            Stmt
nonterminal SimStepList     SimSteps
nonterminal SimStep         SimStep
nonterminal Interrupts      Interrupts
nonterminal ElseStmt        ElseStmt
nonterminal SwitchCaseList  SwitchCases
nonterminal SwitchCase      SwitchCase
nonterminal SwitchDef       SwitchDef
nonterminal Expression      Expression
nonterminal AssignOp        AssignOp
nonterminal FunctionCall    FunctionCall
nonterminal ArgumentList    Arguments
nonterminal ArgumentList    ArgumentList
nonterminal ForIterator     ForIterator
nonterminal Variable        Variable
nonterminal StdLiteral      StdLiterals
nonterminal DclIdList       Dcls
nonterminal TypeIdentifier  TypeId
nonterminal NestedId        NestedId

/* Precedences */
precedence nonassoc OR;
precedence nonassoc AND;
precedence nonassoc EQUALS;
precedence left LESSTHAN, GREATERTHAN, GREATERTHANEQUALS, LESSTHANEQUALS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence right NOT, PLUSPLUS, MINUSMINUS, UMINUS;
precedence left POSTPLUSPLUS, POSTMINUSMINUS;

/* The grammar */
Start         ::= DclBlock:db FunctionDcls:fds1 Program:p FunctionDcls:fds2 EOF                 {: RESULT = new Start(db, fds1, p, fds2, dbleft); :}
              ;
DclBlock      ::= BEGIN DECLARATIONS EOL Stmts:ss END DECLARATIONS EOL                          {: RESULT = new DclBlock(ss, ssleft); :}
              ;
FunctionDcls  ::= FunctionDcls:fds FunctionDcl:fd EOL                                           {: RESULT = fds; fds.addElement(fd); :}
              |                                                                                 {: RESULT = new FunctionDclList(0); :}
              ;
FunctionDcl   ::= FUNCTION TypeId:ti IDENTIFIER:id Params:p EOL Stmts:ss END FUNCTION           {: RESULT = new FunctionDcl(ti, id, p, ss, tileft); :}
              ;
Param         ::= IDENTIFIER:id AS TypeId:ti                                                    {: RESULT = new Param(id, ti, idleft); :}
              ;
Params        ::= LPAREN:l RPAREN                                                               {: RESULT = new ParamList(lleft) :}
              |   LPAREN ParamList:pl RPAREN                                                    {: RESULT = pl; :}
              ;
ParamList     ::= Param:p COMMA ParamList:pl                                                    {: RESULT = pl; pl.addElement(p); :}
              |   Param:p                                                                       {: RESULT = new ParamList(pleft); RESULT.addElement(p); :}
              ;
Program       ::= BEGIN PROGRAM EOL Stmts:ss END PROGRAM EOL                                    {: RESULT = new Program(ss, ssleft); :}
              ;
Stmts         ::= Stmts:ss Stmt:s EOL                                                           {: RESULT = ss; ss.addElement(s); :}
              |                                                                                 {: RESULT = new StmtList(0); :}
              ;
Stmt          ::= DECLARE IDENTIFIER:id Dcls:ds AS TypeId:ti EOL                                {: RESULT = new Dcl(id, ds, ti, idleft); :}
              |   NestedId:ni AssignOp:ao Expression:e EOL                                      {: RESULT = new Assignment(ni, ao, e, nileft); :}
              |   IfStmt:is                                                                     {: RESULT = new IfStmt(e, ss, els, eleft); :}
              |   WHILE Expression:e DO EOL Stmts:ss END WHILE                                  {: RESULT = new WhileStmt(e, ss, eleft); :}
              |   FOREACH TypeId:ti IDENTIFIER:id IN NestedId:ni DO EOL Stmts:ss END FOREACH    {: RESULT = new ForeachStmt(ti, id, ni, ss, tileft); :}
              |   FOR NestedId:ni ForIterator:fi Expression:e DO EOL Stmts:ss END FOR           {: RESULT = new ForStmt(ni, fi, e, ss, nileft); :}
              |   SWITCH Variable:v EOL SwitchCases:swcs SwitchDef:swd END SWITCH               {: RESULT = new SwitchStmt(v, swcs, swd, vleft); :}
              |   RETURN Expression:e                                                           {: RESULT = new ReturnExpr(e, eleft); :}
              |   RETURN:r                                                                      {: RESULT = new Return(rleft); :}
              |   FunctionCall:fc                                                               {: RESULT = new FunctionCall(fc, fcleft); :}
              |   SIMULATION NestedId:ni EOL SimSteps:sis Interrupts:is END SIMULATION          {: RESULT = new SimulationStmt(ni, sis, is, nileft); :}
              ;
SimSteps      ::= SimSteps:sl SimStep:s                                                         {: RESULT = sl; sl.addElement(s); :}
              |                                                                                 {: RESULT = new SimStepList(0); :}
              ;
SimStep       ::= STEP INTEGER_LITERAL:i EOL Stmts:ss                                           {: RESULT = new SimStep(i.intValue, ss, ileft); :}
              ;
Interrupts    ::= INTERRUPTS EOL Stmts:ss                                                       {: RESULT = new Interrupts(ss, ssleft); :}
              ;
IfStmt        ::= IF Expression:e THEN EOL Stmts:ss ElseStmt:els
              |
              ;
ElseStmt      ::= END IF:eif                                                                    {: RESULT = new EndIfStmt :}
              |   ELSE IfStmt:ifs                                                               {: RESULT =  :}
              |   ELSE EOL Stmts:ss END IF                                                      {: RESULT =  :}
              ;              ;
SwitchStmt    ::= SWITCH Variable:v EOL SwitchCases:swcs SwitchDef:swd END SWITCH               {: RESULT =  :}
              ;
SwitchCases   ::= SwitchCases:swcs SwitchCase:swc                                               {: RESULT =  :}
              |                                                                                 {: RESULT =  :}
              ;
SwitchCase    ::= CASE Variable:v EOL Stmts                                                     {: RESULT =  :}
              ;
SwitchDef     ::= DEFAULT EOL Stmts                                                             {: RESULT =  :}
              |                                                                                 {: RESULT =  :}
              ;
Expression    ::= Expression:e1 PLUS Expression:e2                                              {: RESULT =  :}
              |   Expression:e1 MINUS Expression:e2                                             {: RESULT =  :}
              |   Expression:e1 MULT Expression:e2                                              {: RESULT =  :}
              |   Expression:e1 DIV Expression:e2                                               {: RESULT =  :}
              |   Expression:e1 MOD Expression:e2                                               {: RESULT =  :}
              |   Expression:e1 EQUALS Expression:e2                                            {: RESULT =  :}
              |   Expression:e1 LESSTHAN Expression:e2                                          {: RESULT =  :}
              |   Expression:e1 GREATERTHAN Expression:e2                                       {: RESULT =  :}
              |   Expression:e1 LESSTHENEQUALS Expression:e2                                    {: RESULT =  :}
              |   Expression:e1 GREATERTHANEQUALS Expression:e2                                 {: RESULT =  :}
              |   LPAREN Expression:e RPAREN                                                    {: RESULT =  :}
              |   NOT Expression:e                                                              {: RESULT =  :}
              |   MINUS Expression:e %prec UMINUS                                               {: RESULT =  :}
              |   PLUSPLUS Expression:e                                                         {: RESULT =  :}
              |   MINUSMINUS Expression:e                                                       {: RESULT =  :}
              |   Expression:e PLUSPLUS %prec POSTPLUSPLUS                                      {: RESULT =  :}
              |   Expression:e MINUSMINUS %prec POSTMINUSMINUS                                  {: RESULT =  :}
              |   Variable:v                                                                    {: RESULT =  :}
              |   FunctionCall:fc                                                               {: RESULT =  :}
              ;
AssignOp      ::= EQ                                                                            {: RESULT =  :}
              |   PLUSEQ                                                                        {: RESULT =  :}
              |   MINUSEQ                                                                       {: RESULT =  :}
              |   MODEQ                                                                         {: RESULT =  :}
              |   MULTEQ                                                                        {: RESULT =  :}
              |   DIVEQ                                                                         {: RESULT =  :}
              ;
FunctionCall  ::= NestedId:ni Arguments:arg                                                     {: RESULT =  :}
              ;
Arguments     ::= LPAREN RPAREN                                                                 {: RESULT =  :}
              |   LPAREN ArgumentList:al RPAREN                                                 {: RESULT =  :}
              ;
ArgumentList  ::= Expression:e                                                                  {: RESULT =  :}
              |   Expression:e COMMA ArgumentList:al                                            {: RESULT =  :}
              ;
ForIterator   ::= TO                                                                            {: RESULT =  :}
              |   DOWNTO                                                                        {: RESULT =  :}
              ;
Variable      ::= NestedId:ni                                                                   {: RESULT =  :}
              |   StdLiteral:st                                                                 {: RESULT =  :}
              ;
StdLiteral    ::= DECIMAL_LITERAL:dec                                                           {: RESULT =  :}
              |   STRING_LITERAL:str                                                            {: RESULT =  :}
              |   BOOLEAN_LITERAL:bool                                                          {: RESULT =  :}
              |   INTEGER_LITERAL:int // ny?                                                    {: RESULT =  :}
              ;
Dcls          ::= Dcls:ds COMMA IDENTIFIER:id                                                   {: RESULT = ds; ds.addElement(id); :}
              |                                                                                 {: RESULT = new DclIdList(0); :}
              ;
TypeId        ::= DECIMAL                                                                       {: RESULT =  :}
              |   STRING                                                                        {: RESULT =  :}
              |   BOOLEAN                                                                       {: RESULT =  :}
              |   TERRAIN                                                                       {: RESULT =  :}
              |   GROUP                                                                         {: RESULT =  :}
              |   PLATOON                                                                       {: RESULT =  :}
              |   FORCE                                                                         {: RESULT =  :}
              |   COORD                                                                         {: RESULT =  :}
              |   SOLDIER                                                                       {: RESULT =  :}
              |   VOID                                                                          {: RESULT =  :}
              |   LIST OF TypeId:ti                                                             {: RESULT =  :}
              |   TypeId:ty LBRACE StdLiterals RBRACE                                           {: RESULT =  :}
              ;
NestedId      ::= IDENTIFIER:id DOT NestedId:ni                                                 {: RESULT =  :}
              |   IDENTIFIER:id LBRACE Expression:e RBRACE DOT NestedId:ni                      {: RESULT =  :}
              |   IDENTIFIER:id                                                                 {: RESULT =  :}
              ;
